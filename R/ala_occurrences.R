#' Download occurrence data from the ALA
#'
#' @param taxon_id string: single species ID or vector of species ids. Use
#' `ala_taxa()` to get lookup species id.
#' @param filters data.frame: generated by `ala_filters()`
#' @param area string or sf object: restrict the search to an area. Can provide
#' sf object, or a wkt string. WKT strings longer than 10000 characters will
#' not be accepted by the ALA- see the vignette for how to work around this.
#' @param columns string: vector of columns to return in download.
#' @param generate_doi logical: by default no DOI will be generated. Set to
#' true if you intend to use the data in a publication or similar. If
#' generated, DOI is stored in attributes.
#' @param email string: the email address of the user performing the download
#' (required unless \code{record_count_only = TRUE}
#' @param email_notify logical: set to `FALSE` by default, set to true if you
#' would like an email notification for the download
#' @param caching string: should the results be cached? Either "on" or "off"
#' @examples
#' \dontrun{
#' ## Retrieve all machine-observed reptile records in Victoria in the past
#' ## five years, with the default ALA data quality profile
#' id <- ala_taxa("Reptilia")$taxon_concept_id
#' occ <- ala_occurrences(taxon_id = id, filters =
#' ala_filters(list(year = seq(2015, 2020), state = "Victoria")))
#' }
#' @export ala_occurrences

ala_occurrences <- function(taxon_id, filters, area,
                            columns = ala_columns("basic"),
                            email = "ala4r@ala.org.au", generate_doi = FALSE,
                            email_notify = FALSE,
                            caching = "off") {

  assert_that(is.flag(generate_doi))
  assert_that(is.flag(email_notify))
  assert_that(is.character(email))

  query <- list()

  if (missing(taxon_id) & missing(filters) & missing(area)) {
    # stop or allow users to download the whole ALA?
    stop("Need to provide one of `taxon id`, `filters` or `area`")
  }

  if (!missing(taxon_id)) {
    # should species id be validated?
    if (inherits(taxon_id, "data.frame") &&
        "taxon_concept_id" %in% colnames(taxon_id)) {
      taxon_id <- taxon_id$taxon_concept_id
    }
    assert_that(is.character(taxon_id))
    taxa_query <- build_taxa_query(taxon_id)
  } else {
    taxa_query <- NULL
  }
  
  # validate filters
  if (!missing(filters)) {
    assert_that(is.data.frame(filters))
    filter_query <- build_filter_query(filters)
  } else {
    filter_query <- NULL
  }

  query$fq <- c(taxa_query, filter_query)
  
  if (!missing(area)) {
    # convert area to wkt if not already
    area_query <- build_area_query(area)
    query$wkt <- area_query
  } else {
    area_query <- NULL
  }
  
  # Add columns after getting record count
  if (missing(columns)) {
    message("No columns specified, default columns will be returned.")
    columns <- ala_columns("basic")
  }

  # handle caching
  # look for file to download- if it doesn't exist, continue on
  # use base_url_biocache as the filename? otherwise won't be found
  # create cache file with the original query
  cache_file <- cache_filename(c(getOption("ALA4R_server_config")$
                                   base_url_biocache,
                               path = "ws/occurrences/offline/download",
                               params = unlist(query)), ext = ".zip")
  
  if (check_for_caching(taxa_query, filter_query, area_query, columns)) {
    query <- cached_query(taxa_query, filter_query, area_query)
  }

  if (caching == "on" & file.exists(cache_file)) {
    message("Using existing file")
    # look for file using query parameters
    data <- read.csv(unz(cache_file, "data.csv"), stringsAsFactors = FALSE)
    # if file doesn't exist, continue as before
    return(data)
  }

  count <- record_count(query)
  check_count(count)

  assertion_cols <- columns[columns$type == "assertions", ]
  query$fields <- build_columns(columns[columns$type != "assertions", ])
  query$qa <- build_columns(assertion_cols)

  if (generate_doi) {
    query$mintDoi <- "true"
  }

  if (isFALSE(email_notify)) {
    query$emailNotify <- "false"
  }

  # Get data
  url <- getOption("ALA4R_server_config")$base_url_biocache
  query <- c(query, email = email, reasonTypeId = download_reason(),
             dwcHeaders = "true")

  download_path <- wait_for_download(url, query)
  data_path <- ala_download(url = "https://biocache.ala.org.au",
                       path = download_path,
                       cache_file = cache_file, ext = ".zip")
  df <- read.csv(unz(data_path, "data.csv"), stringsAsFactors = FALSE)

  # rename cols so they match requested cols
  names(df) <- rename_columns(names(df), type = "occurrence")

  # replace 'true' and 'false' with boolean
  if (nrow(assertion_cols) > 0) {
    df <- fix_assertion_cols(df, assertion_cols$name)
  }

  # add DOI as attribute
  doi <- NA
  if (generate_doi) {
    try({
      doi_file <- read.table(unz(data_path, "doi.txt"))
      doi <- as.character(doi_file$V1)
      attr(df, "doi") <- doi},
      silent = TRUE)
  }

  if (generate_doi && is.na(doi)) {
    warning("No DOI was generated for download. The DOI server may
                        be down. Please try again later")
  }
  return(df)
}



wait_for_download <- function(url, query) {
  status <- ala_GET(url, "ws/occurrences/offline/download",
                    params = query)

  status_url <- parse_url(status$statusUrl)
  status <- ala_GET(url, path = status_url$path)
  while (tolower(status$status) %in% c("inqueue", "running")) {
    status <- ala_GET(url, path = status_url$path)
    Sys.sleep(2)
  }
  parse_url(status$downloadUrl)$path
}

check_count <- function(count) {
  if (count == 0) {
    stop("This query does not match any records.")
  } else if (count > 50000000) {
    stop("A maximum of 50 million records can be retrieved at once.",
         " Please narrow the query and try again.")
  } else {
    message("This query will return ", count, " records")
  }
}

download_reason <- function() {
  reason <- Sys.getenv("ala_download_reason")
  if (reason == "") {
    reason <- default_download_reason()
  } else {
   reason <- validate_download_reason(reason)
  }
  reason
}

default_download_reason <- function() {
  4
}

validate_download_reason <- function(reason) {
  if (is.character(reason)) {
    reason <- ala_reasons()[ala_reasons()$name == reason,]$id
  }
  if (!(reason %in% ala_reasons()$id)) {
   stop("Download reason must be a valid reason id or name ",
        "See `ala_reasons()` for valid reasons.") 
  }
  reason
}

